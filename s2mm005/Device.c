/*++

Module Name:

	device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.

Environment:

	Kernel-mode Driver Framework

--*/

#include "driver.h"
#include <wdmguid.h>
#define RESHUB_USE_HELPER_ROUTINES
#include <reshub.h>
#include <gpio.h>
#include <wdf.h>
#include "s2mm005.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, s2mm005CreateDevice)
#pragma alloc_text(PAGE, s2mm005DevicePrepareHardware)
#endif

NTSTATUS
s2mm005CreateDevice(
	_Inout_ PWDFDEVICE_INIT DeviceInit)
	/*++

	Routine description:

		Worker routine called to create a device and its software resources.

	Arguments:

		DeviceInit - Pointer to an opaque init structure. Memory for this
						structure will be freed by the framework when the WdfDeviceCreate
						succeeds. So don't access the structure after that point.

	Return Value:

		NTSTATUS

	--*/
{
	WDF_OBJECT_ATTRIBUTES deviceAttributes;
	PDEVICE_CONTEXT deviceContext;
	WDFDEVICE device;
	NTSTATUS status;
	WDF_PNPPOWER_EVENT_CALLBACKS PnpPowerCallbacks;

	PAGED_CODE();

	//
	// Initialize the PnpPowerCallbacks structure.  Callback events for PNP
	// and Power are specified here.
	//

	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&PnpPowerCallbacks);
	PnpPowerCallbacks.EvtDevicePrepareHardware = s2mm005DevicePrepareHardware;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &PnpPowerCallbacks);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

	if (NT_SUCCESS(status))
	{
		//
		// Get a pointer to the device context structure that we just associated
		// with the device object. We define this structure in the device.h
		// header file. DeviceGetContext is an inline function generated by
		// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
		// This function will do the type checking and return the device context.
		// If you pass a wrong object handle it will return NULL and assert if
		// run under framework verifier mode.
		//
		deviceContext = (PDEVICE_CONTEXT)DeviceGetContext(device);

		//
		// Initialize the context.
		//
		deviceContext->Device = device;
	}

	return status;
}

_Use_decl_annotations_
NTSTATUS
s2mm005DevicePrepareHardware(
	WDFDEVICE Device,
	WDFCMRESLIST ResourcesRaw,
	WDFCMRESLIST ResourcesTranslated)

	/*++

	Routine description:

		EvtDevicePrepareHardware event callback performs operations that are
		necessary to make the driver's device operational. The framework calls the
		driver's EvtDevicePrepareHardware callback when the PnP manager sends an
		IRP_MN_START_DEVICE request to the driver stack.

	Arguments:

		Device - Supplies a handle to a framework device object.

		ResourcesRaw - Supplies a handle to a collection of framework resource
			objects. This collection identifies the raw (bus-relative) hardware
			resources that have been assigned to the device.

		ResourcesTranslated - Supplies a handle to a collection of framework
			resource objects. This collection identifies the translated
			(system-physical) hardware resources that have been assigned to the
			device. The resources appear from the CPU's point of view. Use this list
			of resources to map I/O space and device-accessible memory into virtual
			address space

	Return Value:

		NTSTATUS

	--*/

{
	NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR res, resRaw;
	ULONG TypeC_Status_initial;
	WDF_INTERRUPT_CONFIG interruptConfig;
	ULONG resourceCount;
	ULONG i;

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "Entering %!FUNC!\n");
	PAGED_CODE();

	PDEVICE_CONTEXT devContext = DeviceGetContext(Device);

	devContext->Device = Device;

	//
	// Get the resouce hub connection ID for our I2C driver
	//
	resourceCount = WdfCmResourceListGetCount(ResourcesTranslated);

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"Looking for resources");

	BOOLEAN I2CFound = FALSE;
    BOOLEAN InterruptFound = FALSE;
    ULONG interruptIndex = 0;

	for (i = 0; i < resourceCount; i++)
	{
		res = WdfCmResourceListGetDescriptor(ResourcesTranslated, i);
		resRaw = WdfCmResourceListGetDescriptor(ResourcesRaw, i);

		switch (res->Type)
		{
		case CmResourceTypeConnection:
		{
			if (res->u.Connection.Class == CM_RESOURCE_CONNECTION_CLASS_SERIAL &&
				res->u.Connection.Type == CM_RESOURCE_CONNECTION_TYPE_SERIAL_I2C)
			{
				devContext->I2CContext.I2cResHubId.LowPart =
					res->u.Connection.IdLowPart;
				devContext->I2CContext.I2cResHubId.HighPart =
					res->u.Connection.IdHighPart;

				TraceEvents(
					TRACE_LEVEL_INFORMATION,
					TRACE_DRIVER,
					"Found I2C!");

				I2CFound = TRUE;
			}
			break;
		}
		case CmResourceTypeInterrupt:
		{
		    if (InterruptFound = FALSE)
			{
				WDF_INTERRUPT_CONFIG_INIT(
					&interruptConfig,
					OnInterruptIsr,
					NULL
				);

				interruptConfig.InterruptTranslated = res;
				interruptConfig.InterruptRaw = resRaw;
				interruptConfig.PassiveHandling = TRUE;

				status = WdfInterruptCreate(
					Device,
					&interruptConfig,
					WDF_NO_OBJECT_ATTRIBUTES,
					&devContext->Interrupt
				);

				if (!NT_SUCCESS(status))
				{
					TraceEvents(
						TRACE_LEVEL_ERROR,
						TRACE_DRIVER,
						"WdfInterruptCreate failed %!STATUS!",
						status
					);

					goto exit;
				}
			}
			InterruptFound = TRUE;
			break;
		}
		default:
			//
			// Ignoring all other resource types.
			//
			break;
		}
	}

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"Initializing I2C Bus");

	//
	// Initialize Spb so the driver can issue reads/writes
	//
	status = SpbTargetInitialize(Device, &devContext->I2CContext);

	if (!NT_SUCCESS(status))
	{
		TraceEvents(
			TRACE_LEVEL_ERROR,
			TRACE_DRIVER,
			"Error in Spb initialization - %!STATUS!",
			status);

		goto exit;
	}

	devContext->InitializedSpbHardware = TRUE;

exit:
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "Leaving %!FUNC!: Status = 0x%08lX\n", status);
	return status;
}

VOID s2mm005DeviceUnPrepareHardware(
	WDFDEVICE Device)
{
	PDEVICE_CONTEXT devContext = DeviceGetContext(Device);

	if (devContext == NULL)
	{
		return;
	}

	if (devContext->InitializedSpbHardware)
	{
		SpbTargetDeinitialize(Device, &devContext->I2CContext);
		devContext->InitializedSpbHardware = FALSE;
	}
}